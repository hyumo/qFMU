///////////////////////////////////////////////////////////////////////////////
// 
//  PLEASE DO NOT MODIFY
// 
///////////////////////////////////////////////////////////////////////////////

#include "fmi2.h"

#ifdef __cplusplus
extern "C" {
#endif

#define MODEL_IDENTIFIER {{identifier}}
#define MODEL_GUID "{{guid}}"

#define NR {{nr}} 
#define NX {{nx}}
#define NU {{nu}}
#define NY {{ny}}

// macro to be used to log messages. The macro check if current 
// log category is valid and, if true, call the logger provided by simulator.
#define FILTERED_LOG(instance, status, categoryIndex, message, ...) if (status == fmi2Error || status == fmi2Fatal || isCategoryLogged(instance, categoryIndex)) \
        instance->functions->logger(instance->functions->componentEnvironment, instance->instanceName, status, \
        logCategoriesNames[categoryIndex], message, ##__VA_ARGS__);

typedef struct {
    ModelState state;
    fmi2Real r[{{nr}}];
    fmi2Real time;
    fmi2Char instanceName[256]; // TODO: change 256 by a max_str_len parameter from user argv
    fmi2Type type;
    fmi2String GUID;
    const fmi2CallbackFunctions *functions;
    fmi2Boolean loggingOn;
    fmi2Boolean logCategories[NUMBER_OF_CATEGORIES];
    fmi2ComponentEnvironment componentEnvironment;
    fmi2Boolean isDirtyValues;
} ModelInstance;

static const fmi2String logCategoriesNames[] = {"logAll", "logError", "logFmiCall", "logEvent"};
static ModelInstance instance;
{{% if nx > 0 %}}
#define _X   (comp->r + {{vr0["x"]}})
#define _DER (comp->r + {{vr0["der"]}})
#define _X0  (comp->r + {{vr0["x0"]})
{{% endif %}}
{{% if nu > 0 %}}
#define _U   (comp->r + {{vr0["u"]}})
#define _U0  (comp->r + {{vr0["u0"]}})
{{% endif %}}
#define _Y   (comp->r + {{vr0["y"]}})
{{% if nx > 0 %}}
static const fmi2ValueReference vrStates[{{nx}}] = { {{",".join(vrs["x"])}} };
static const fmi2ValueReference vrDers[{{nx}}] = { {{",".join(vrs["der"])}} };
{{% endif %}}
static const fmi2ValueReference vrOutputs[{{ny}}] = { {{",".join(vrs["y"])}} };

{{% if nx > 0 %}}
static const fmi2Real A[{{nx}}][{{nx}}] = {
    {{% for row in A %}}}
    { {{row}} },
    {{% endif %}}
};
static const fmi2Real B[{{nx}}][{{nu}}] = {
    {{% for row in B %}}
    { {{row}} },
    {{% endif %}}
};
static const fmi2Real C[{{ny}}][{{nx}}] = {
    {{% for row in C %}}
    { {{row}} },
    {{% endif %}}
};
{{ %endif %}}

{{% if nu > 0 %}}
static const fmi2Real D[{{ny}}][{{nu}}] = {
    {{% for row in D %}}
    { {{row}} },
    {{% endif %}}
};
{{ %endif %}}
{{% if nx > 0 %}}
static const fmi2Real x0_reset[{{nx}}] = { {{",".join(x0)}} };
{{ %endif %}}
{{% if nu > 0 %}}
static const fmi2Real u0_reset[{{nu}}] = { {{",".join(u0)}} };
{{ %endif %}}